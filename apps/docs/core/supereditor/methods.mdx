---
title: Methods
keywords: "supereditor methods, editor commands, document manipulation, editor api"
---

## Document lifecycle

### `open`

Open a document from a file, URL, or buffer.

<ParamField path="source" type="string | File | Blob | Buffer">
  Document source. Omit for a blank document.
</ParamField>

<ParamField path="options" type="OpenOptions">
  <Expandable title="properties">
    <ParamField path="mode" type="string" default="'docx'">
      `'docx'`, `'text'`, or `'html'`
    </ParamField>
    <ParamField path="html" type="string">
      HTML content (for text/html mode)
    </ParamField>
    <ParamField path="markdown" type="string">
      Markdown content
    </ParamField>
    <ParamField path="json" type="Object">
      ProseMirror JSON to use instead of DOCX parsing
    </ParamField>
  </Expandable>
</ParamField>

```javascript
await editor.open(docxFile);
await editor.open(null, { mode: 'html', html: '<p>Hello</p>' });
```

<Note>
This is the instance method. For one-liner creation, use the static `Editor.open()` factory — see [Configuration](/core/supereditor/configuration).
</Note>

### `close`

Close the current document. The editor instance stays alive for reuse.

```javascript
editor.close();
await editor.open(anotherFile);
```

### `save`

Save back to the original source path (Node.js only).

<ParamField path="options" type="SaveOptions">
  <Expandable title="properties">
    <ParamField path="isFinalDoc" type="boolean" default="false">
      Replace fields with values
    </ParamField>
    <ParamField path="commentsType" type="string" default="'external'">
      Comment handling
    </ParamField>
    <ParamField path="comments" type="Array">
      Comments to include
    </ParamField>
    <ParamField path="fieldsHighlightColor" type="string" default="'#FFFF00'">
      Field highlight color
    </ParamField>
  </Expandable>
</ParamField>

```javascript
await editor.save();
await editor.save({ isFinalDoc: true });
```

<Warning>Throws if the editor was opened from a Blob/Buffer instead of a file path. Use `saveTo()` or `exportDocument()` instead.</Warning>

### `saveTo`

Save to a specific path (Node.js only).

<ParamField path="path" type="string" required>
  File path
</ParamField>

```javascript
await editor.saveTo('/path/to/output.docx');
```

### `exportDocument`

Export as a Blob (browser) or Buffer (Node.js).

```javascript
const blob = await editor.exportDocument();
const blob = await editor.exportDocument({ isFinalDoc: true });
```

### `exportDocx`

Lower-level export with additional control.

<ParamField path="options" type="Object">
  <Expandable title="properties">
    <ParamField path="isFinalDoc" type="boolean" default="false">
      Replace fields with values
    </ParamField>
    <ParamField path="commentsType" type="string" default="'external'">
      `'external'`, `'clean'`, or custom
    </ParamField>
    <ParamField path="comments" type="Array">
      Comments to include — [data structure](/modules/comments#comment-data-structure)
    </ParamField>
    <ParamField path="fieldsHighlightColor" type="string" default="'#FFFF00'">
      Field highlight color
    </ParamField>
  </Expandable>
</ParamField>

```javascript
const blob = await editor.exportDocx({
  isFinalDoc: true,
  commentsType: 'clean'
});
```

### `replaceFile`

Replace the current DOCX with a new file.

```javascript
await editor.replaceFile(newDocxFile);
```

## Content

### `getHTML`

```javascript
const html = editor.getHTML();
const html = editor.getHTML({ unflattenLists: true });
```

### `getJSON`

```javascript
const json = editor.getJSON();
```

### `getMarkdown`

```javascript
const md = await editor.getMarkdown();
```

### `replaceContent`

Replace the entire document content.

```javascript
editor.replaceContent(proseMirrorJson);
```

### `replaceNodeWithHTML`

Replace a specific node with HTML.

```javascript
const table = editor.getNodesOfType('table')[0];
editor.replaceNodeWithHTML(table, '<table>...</table>');
```

## Editor control

### `mount` / `unmount`

```javascript
editor.mount(document.querySelector('#editor'));
editor.unmount(); // Keeps instance alive
```

### `destroy`

Permanently destroy the editor.

<Warning>Irreversible. The instance cannot be used after this.</Warning>

```javascript
editor.destroy();
```

### `focus` / `blur`

```javascript
editor.focus();
editor.blur();
```

### `setEditable`

```javascript
editor.setEditable(false); // Read-only
editor.setEditable(true);  // Editable
```

### `setDocumentMode`

```javascript
editor.setDocumentMode('editing');    // Full editing
editor.setDocumentMode('suggesting'); // Track changes
editor.setDocumentMode('viewing');    // Read-only
```

## Commands

All commands are accessed via `editor.commands`:

```javascript
// Formatting
editor.commands.toggleBold();
editor.commands.toggleItalic();
editor.commands.toggleUnderline();

// Tables
editor.commands.insertTable({ rows: 3, cols: 3 });

// Selection
editor.commands.setTextSelection({ from: 10, to: 20 });
editor.commands.selectAll();
```

### `insertContent`

Insert content with automatic format detection.

<ParamField path="content" type="string | Object" required>
  Content to insert
</ParamField>

<ParamField path="options" type="Object">
  <Expandable title="properties">
    <ParamField path="contentType" type="string">
      `'html'`, `'markdown'`, `'text'`, or `'schema'`
    </ParamField>
    <ParamField path="position" type="number | Object">
      Insert position (defaults to cursor)
    </ParamField>
  </Expandable>
</ParamField>

```javascript
editor.commands.insertContent(htmlContent, { contentType: 'html' });
editor.commands.insertContent(markdownText, { contentType: 'markdown' });
editor.commands.insertContent('Plain text', { contentType: 'text' });
```

<Note>HTML and Markdown inline styles are stripped on import to ensure Word compatibility.</Note>

## Document metadata

### `getMetadata`

```javascript
const { documentGuid, isModified, version } = editor.getMetadata();
```

### `getDocumentIdentifier`

Get a stable identifier (GUID or content hash).

```javascript
const id = await editor.getDocumentIdentifier();
```

### `isDocumentModified`

```javascript
if (editor.isDocumentModified()) {
  // Prompt user to save
}
```

## Schema

### `getSchemaSummaryJSON`

Generate a summary of the document schema. Useful for AI agents that need to understand the document structure.

```javascript
const summary = await editor.getSchemaSummaryJSON();
```

## Position & coordinates

### `getElementAtPos`

Get the DOM element at a document position.

<ParamField path="pos" type="number" required>
  Document position
</ParamField>

```javascript
const element = editor.getElementAtPos(42);
```

### `getNodesOfType`

Get all nodes of a specific type.

```javascript
const tables = editor.getNodesOfType('table');
const paragraphs = editor.getNodesOfType('paragraph');
```

### `isActive`

Check if a node or mark is active.

```javascript
editor.isActive('bold');
editor.isActive('heading', { level: 2 });
```

### `getAttributes`

Get attributes of the active node or mark.

```javascript
const attrs = editor.getAttributes('link');
console.log(attrs.href);
```

## Page & layout

### `getPageStyles`

```javascript
const styles = editor.getPageStyles();
```

### `updatePageStyle`

```javascript
editor.updatePageStyle({
  pageMargins: { top: '1in', bottom: '1in', left: '1in', right: '1in' }
});
```

## Search

```javascript
const results = editor.commands.search('hello');
const results = editor.commands.search(/\d{3}-\d{4}/gi);

editor.commands.goToSearchResult(results[0]);
```

## Properties

| Property | Type | Description |
|---|---|---|
| `lifecycleState` | `string` | `'initialized'`, `'documentLoading'`, `'ready'`, `'saving'`, `'closed'`, `'destroyed'` |
| `isEditable` | `boolean` | Whether editor accepts input |
| `isDestroyed` | `boolean` | Whether editor has been destroyed |
| `isFocused` | `boolean` | Whether editor has focus |
| `docChanged` | `boolean` | Whether any edits have been made |
| `sourcePath` | `string \| null` | Source file path (null if opened from Blob) |
